import "rpcmessage.proto";

package transport;

enum SubType {
  kACK = 0;
  kNACK = 1;
}

message Address {
  required bytes ip = 1;
  required int32 port = 2;
}

message Ping {
  optional Address from_address = 1;
}

message ProxyPing {
  optional SubType result = 1;
  optional Address address = 2;
}

message ManagedEndpointMessage {
  optional Address address = 1;
  optional SubType result = 2;
  optional bytes identifier = 3;
  optional int32 frequency = 4;
  optional int32 retry_count = 5;
  optional int32 retry_frequency = 6;
}

message HolePunchingMessage {
  required bytes ip = 1;
  required int32 port = 2;
  required msg_type type = 3;
  enum msg_type {
    FORWARD_REQ = 0;
    FORWARD_MSG = 1;
  }
}

message TransportMessage {
  enum Type {
    kRequest = 0;  // leave socket available to send the response on
    kResponse = 1;  // socket is closed on receiving this type unless it's a managed connection
  }
  message Data {
    extensions 100 to 18999;  // Allows extensions of the message types
    optional bytes raw_message = 1;
    optional rpcprotocol.RpcMessage rpc_message = 2;
    optional HolePunchingMessage hole_punching_message = 3;
    optional Ping ping = 4;
    optional ProxyPing proxy_ping = 5;
    optional ManagedEndpointMessage managed_endpoint_message = 6;
  }
  required Type type = 1;
  required Data data = 2;
}

// To add a message elsewhere (outside this library) type do this
//  package transport; // to get this namespace
//  extend TransportMessage.Data {
//    optional NewMessageType my_message = 100;
//    optional AnotherNewMessageType my_other_message = 101;
//  }
//
//

