import "maidsafe/protobuf/contact_info.proto";
import "maidsafe/protobuf/transport_message.proto";
import "maidsafe/protobuf/signed_kadvalue.proto";

package transport;

message PingRequest {
  extend TransportMessage.Data {
    optional PingRequest ping_request = 100;
  }
  required bytes ping = 1;
  required kademlia.ContactInfo sender_info = 2;
}

message PingResponse {
  extend transport.TransportMessage.Data {
    optional PingResponse ping_response = 101;
  }
  required bool result = 1;
  optional bytes echo = 2;
  optional bytes node_id = 3;
};

message FindRequest {
  extend transport.TransportMessage.Data {
    optional FindRequest find_request = 102;
  }
  required bytes key = 1;
  required kademlia.ContactInfo sender_info = 2;
  optional bool is_boostrap = 3;
  optional bytes sender_ext_ip = 4;
  optional int32 sender_ext_port = 5;
};

message FindResponse {
  extend transport.TransportMessage.Data {
    optional FindResponse find_response = 103;
  }
  required bool result = 1;
  repeated bytes closest_nodes = 2;
  repeated bytes values = 3;
  repeated kademlia.SignedValue signed_values = 4;
  optional kademlia.ContactInfo alternative_value_holder = 5;
  optional bytes needs_cache_copy = 6;
  optional bytes requester_ext_addr = 7;
  optional bytes node_id = 8;
};

message FindNodeResult {
  extend transport.TransportMessage.Data {
    optional FindNodeResult find_node_result = 104;
  }
  required bool result = 1;
  optional bytes contact = 2;
  optional bytes node_id = 3;
};

message StoreRequest {
  extend transport.TransportMessage.Data {
    optional StoreRequest store_request = 105;
  }
  required bytes key = 1;
  optional bytes value = 2;
  optional kademlia.SignedValue sig_value = 3;
  required int32 ttl = 4;
  required kademlia.ContactInfo sender_info = 5;
  required bool publish = 6;
  optional kademlia.SignedRequest signed_request = 7;
};

message StoreResponse {
  extend transport.TransportMessage.Data {
    optional StoreResponse store_response = 106;
  }
  required bool result = 1;
  optional bytes node_id = 2;
  optional kademlia.SignedRequest signed_request = 3;
};

message DeleteRequest {
  extend transport.TransportMessage.Data {
    optional DeleteRequest delete_request = 107;
  }
  required bytes key = 1;
  required kademlia.SignedValue value = 2;
  required kademlia.SignedRequest signed_request = 3;
  required kademlia.ContactInfo sender_info = 4;
};

message DeleteResponse {
  extend transport.TransportMessage.Data {
    optional DeleteResponse delete_response = 108;
  }
  required bool result = 1;
  optional bytes node_id = 2;
};

message UpdateRequest {
  extend transport.TransportMessage.Data {
    optional UpdateRequest update_request = 109;
  }
  required bytes key = 1;
  required kademlia.SignedValue new_value = 2;
  required kademlia.SignedValue old_value = 3;
  required int32 ttl = 4;
  required kademlia.SignedRequest request = 5;
  required kademlia.ContactInfo sender_info = 6;
};

message UpdateResponse {
  extend transport.TransportMessage.Data {
    optional UpdateResponse update_response = 110;
  }
  required bool result = 1;
  optional bytes node_id = 2;
};

message DownlistRequest {
  extend transport.TransportMessage.Data {
    optional DownlistRequest downlist_request = 111;
  }
  repeated bytes downlist = 1;
  required kademlia.ContactInfo sender_info = 2;
};

message DownlistResponse {
  extend transport.TransportMessage.Data {
    optional DownlistResponse downlist_response = 112;
  }
  required bool result = 1;
  optional bytes node_id = 2;
};

message NatDetectionRequest {
  extend transport.TransportMessage.Data {
    optional NatDetectionRequest nat_detection_request = 113;
  }
  required bytes newcomer = 1;
  required bytes bootstrap_node = 2;
  required int32 type = 3;  //1: Node B asks C to try ping A; 2: Node B asks C to try a rendezvous to A with B as rendezvous
  required bytes sender_id = 4;
};

message NatDetectionResponse {
  extend transport.TransportMessage.Data {
    optional NatDetectionResponse nat_detection_response = 114;
  }
  required bool result = 1;
};

message NatDetectionPingRequest {
  extend transport.TransportMessage.Data {
    optional NatDetectionPingRequest nat_detection_ping_request = 115;
  }
  required bytes ping = 1;
};

message NatDetectionPingResponse {
  extend transport.TransportMessage.Data {
    optional NatDetectionPingResponse nat_detection_ping_response = 116;
  }
  required bool result = 1;
  optional bytes echo = 2;
  optional bytes node_id = 3;
};

message BootstrapRequest {
  extend transport.TransportMessage.Data {
    optional BootstrapRequest bootstrap_request = 117;
  }
  required bytes newcomer_id = 1;
  required bytes newcomer_local_ip = 2;
  required int32 newcomer_local_port = 3;
  required int32 node_type = 4;
  optional bytes newcomer_ext_ip = 5;
  optional int32 newcomer_ext_port = 6;
};

message BootstrapResponse {
  extend transport.TransportMessage.Data {
    optional BootstrapResponse bootstrap_response = 118;
  }
  required bool result = 1;
  optional bytes bootstrap_id = 2;
  optional bytes newcomer_ext_ip = 3;
  optional int32 newcomer_ext_port = 4;
  optional int32 nat_type = 5; // 1: directly connected or behind full-cone router or ...
                               // 2: need rendezvous server to punch the hole
                               // 3. no connection
};
